msgid ""
msgstr ""
"Project-Id-Version: \n"
"PO-Revision-Date: 2017-02-27 15:44+0900\n"
"Last-Translator: Keiji Suzuki <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"POT-Creation-Date: \n"
"X-Generator: Poedit 1.8.12\n"

#. TRANSLATORS: Elixir.HTTPoison.Base Summary
#: lib/httpoison/base.ex:2
msgid ""
"Provides a default implementation for HTTPoison functions.\n"
"\n"
"This module is meant to be `use`'d in custom modules in order to wrap the\n"
"functionalities provided by HTTPoison. For example, this is very useful to\n"
"build API clients around HTTPoison:\n"
"\n"
"    defmodule GitHub do\n"
"      use HTTPoison.Base\n"
"\n"
"      @endpoint \"https://api.github.com\"\n"
"\n"
"      def process_url(url) do\n"
"        @endpoint <> url\n"
"      end\n"
"    end\n"
"\n"
"The example above shows how the `GitHub` module can wrap HTTPoison\n"
"functionalities to work with the GitHub API in particular; this way, for\n"
"example, all requests done through the `GitHub` module will be done to the\n"
"GitHub API:\n"
"\n"
"    GitHub.get(\"/users/octocat/orgs\")\n"
"    #=> will issue a GET request at https://api.github.com/users/octocat/"
"orgs\n"
"\n"
"## Overriding functions\n"
"\n"
"`HTTPoison.Base` defines the following list of functions, all of which can "
"be\n"
"overridden (by redefining them). The following list also shows the "
"typespecs\n"
"for these functions and a short description.\n"
"\n"
"    # Called in order to process the url passed to any request method "
"before\n"
"    # actually issuing the request.\n"
"    @spec process_url(binary) :: binary\n"
"    def process_url(url)\n"
"\n"
"    # Called to arbitrarily process the request body before sending it with "
"the\n"
"    # request.\n"
"    @spec process_request_body(term) :: binary\n"
"    def process_request_body(body)\n"
"\n"
"    # Called to arbitrarily process the request headers before sending "
"them\n"
"    # with the request.\n"
"    @spec process_request_headers(term) :: [{binary, term}]\n"
"    def process_request_headers(headers)\n"
"\n"
"    # Called before returning the response body returned by a request to "
"the\n"
"    # caller.\n"
"    @spec process_response_body(binary) :: term\n"
"    def process_response_body(body)\n"
"\n"
"    # Used when an async request is made; it's called on each chunk that "
"gets\n"
"    # streamed before returning it to the streaming destination.\n"
"    @spec process_response_chunk(binary) :: term\n"
"    def process_response_chunk(chunk)\n"
"\n"
"    # Called to process the response headers before returning them to the\n"
"    # caller.\n"
"    @spec process_headers([{binary, term}]) :: term\n"
"    def process_headers(headers)\n"
"\n"
"    # Used to arbitrarily process the status code of a response before\n"
"    # returning it to the caller.\n"
"    @spec process_status_code(integer) :: term\n"
"    def process_status_code(status_code)\n"
"\n"
msgstr ""
"HTTPoison関数のデフォルト実装を提供する。\n"
"\n"
"このモジュールはHTTPoisonで提供されている機能をラップするために\n"
"カスタムモジュールで`use`されることを意図している。たとえば、\n"
"HTTPoisonでAPIクライアントを構築する際に非常に便利である。\n"
"\n"
"    defmodule GitHub do\n"
"      use HTTPoison.Base\n"
"\n"
"      @endpoint \"https://api.github.com\"\n"
"\n"
"      def process_url(url) do\n"
"        @endpoint <> url\n"
"      end\n"
"    end\n"
"\n"
"この例は、`GitHub`モジュールがどのようにHTTPoisonの機能をラップして、\n"
"特にGitHub APIを使用しているかを示している。たとえば、`GItHub`モジュールを\n"
"介して実行されるすべてのリクエストはGitHub APIに対して行われる。\n"
"\n"
"    GitHub.get(\"/users/octocat/orgs\")\n"
"    #=> https://api.github.com/users/octocat/orgsにGETリクエストを発行する\n"
"\n"
"## 関数の上書き\n"
"\n"
"`HTTPoison.Base`は次の関数を定義している。そのすべては\n"
"（定義することで）上書き可能である。次のリストは各関数の\n"
"型仕様と簡単な説明も示している。\n"
"\n"
"    # 実際にリクエストを発行する前に任意のリクエストメソッドに渡される\n"
"    # URLを処理するために呼び出される。\n"
"    @spec process_url(binary) :: binary\n"
"    def process_url(url)\n"
"\n"
"    # リクエストで送信する前にリクエストボディに何らかの処理をするために\n"
"    # 呼び出される。\n"
"    @spec process_request_body(term) :: binary\n"
"    def process_request_body(body)\n"
"\n"
"    # リクエストで送信する前にリクエストヘッダに何らかの処理をするために\n"
"    # 呼び出される。\n"
"    @spec process_request_headers(term) :: [{binary, term}]\n"
"    def process_request_headers(headers)\n"
"\n"
"    # リクエストにより返されたレスポンスボディを呼び出し元に返す前に\n"
"    # 呼び出される。\n"
"    @spec process_response_body(binary) :: term\n"
"    def process_response_body(body)\n"
"\n"
"    # 非同期リクエストを行う際に使用される。ストリームに流すチャンクを\n"
"    # ストリーミング先に返す前にチャンク毎に呼び出される。\n"
"    @spec process_response_chunk(binary) :: term\n"
"    def process_response_chunk(chunk)\n"
"\n"
"    # 呼び出し元に返す前にレスポンスヘッダを処理するために\n"
"    # 呼び出される。\n"
"    @spec process_headers([{binary, term}]) :: term\n"
"    def process_headers(headers)\n"
"\n"
"    # 呼び出し元に返す前にレスポンスステータスに何らかの処理を行う\n"
"    # のに使用される。\n"
"    @spec process_status_code(integer) :: term\n"
"    def process_status_code(status_code)\n"
"\n"
"\n"
